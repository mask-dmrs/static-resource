# 处理属性
---
*Martin Fowler*   <P>
fowler@acm.org
---
- 几乎你创建的每个对象都需要属性：关于对象的一些声明。一个人可能有一个高度，一个公司可能有一个CEO，一个航班可能有一个航班号。有很多方法来建模属性。在这篇文章中，我将探讨
其中一些方法，当你可能想要使用它们。我经常看到图案触及这个主题，但他们通常只涉及部分图片。在这里，我想更广泛地讨论这个问题，以便更好地讨论这些选项。

- 最常见和最简单的情况是使用固定属性，即只声明类的属性。在绝大多数情况下，你只需要做。固定属性在有大量固定属性时会失败，或者需要频繁更改，可能在运行时。这些力量带领您到各种各样的动态财产。所有动态属性都具有参数化属性的质量，在这里查询需要使用带有参数的查询方法的属性。其中最简单的是灵活的动态属性，其中参数只是一个字符串。这使得定义和使用属性变得容易，但难以控制。如果您需要该控件，则可以使用“定义的动态属性”，其中参数必须是某个类的实例。进一步的控制步骤允许您强有力地键入您的动态属性与类型动态属性。

- 随着您的财产结构变得越来越复杂，您应该考虑将它们设置为“单独属性”，从而使属性成为一个对象。如果你需要多值属性，你可以考虑一个类型化的关系。在这个主题中最复杂的例子是你想要规则来控制什么类型的对象具有什么样的属性 - 这需要动态属性知识水平。

- 另一种属性完全是外部属性（Extrinsic Property），如果你想给一个对象一个属性，但是不改变它的接口来支持它，那么就是你使用的一种模式。

Problem	|Solution	|Name	|page
--- | --- | --- | ---
 &nbsp;  |给它一个这个事实的特定属性。这将转化为查询方法，并可能是一种编程语言的更新方法.|[固定属性](#固定属性)|4
 &nbsp;  |提供可参数化的属性，可以根据参数表示不同的属性|[动态属性](#动态属性)|4
 &nbsp;  |提供一个用字符串参数化的属性。声明一个属性只是使用字符串.|灵活的动态属性|5
 &nbsp;  |提供用某种类型的实例参数化的属性。要声明属性，请创建该类型的新实例|定义的动态属性|7
 &nbsp;  |提供使用某种类型的实例进行参数化的属性。要声明属性，请创建该类型的新实例并指定该属性的值类型.|类型动态属性|9
你如何代表一个事物的事实，并允许事实记录有关的事实|为每个属性创建一个单独的对象。 关于那个财产的事实可以作为这个财产的属性|分开的属性	|10
你如何表示两个对象之间的关系（如何表示多值动态属性？）|为两个对象之间的每个链接创建一个关系对象。 给关系对象一个类型对象来表示关系的含义。 （类型对象是多值属性的名称。）|类型关系| 14
当你使用动态属性时，你如何强制某些类型的对象具有某些属性？ |创建知识级别以包含哪些类型的对象使用哪些类型的属性的规则 |动态财产知识水平| 16
你如何给一个对象一个属性而不改变它的接口？|使另一个对象负责知道属性| 外在性质| 18

---
## 什么是属性
- 这不是一个愚蠢的问题。当人们围绕“属性”这个词来分支时，他们可能意味着很多不同的东西。对某些属性来说，是一个类的实例变量或数据成员。对于其他人来说，它们就像UML图中的一个盒子一样。所以在我开始这篇文章之前，我必须定义这个词的用法。

- 为了我的目的，一个属性是关于一个可以通过查询方法获得的对象的一些信息。它可能是一个值类型（如Java中的int）或一个类的实例。您可能能够更新该属性，但不一定。您可以在创建对象时设置属性，但不一定。该属性可以作为实例变量或数据成员存储，但不一定是。班级可能会从另一个班级获得价值，或者经过一些进一步的计算。因此，我采用属性的接口视图而不是实现视图。这是我在设计中经常使用的习惯：对于我来说，面向对象的本质是将接口与实现分开，并使接口更加重要。
---

## <span id = "固定属性">固定属性</span>
- 固定属性是我们使用的最常见的属性。 固定属性在类型的接口中声明。 它给出了属性的名称和返回类型。 图1显示了使用UML建模的属性，清单1显示了这些属性的查询方法如何在Java中显示。 我已经选择了这个例子来说明这个讨论同样适用于UML属性和UML关联。 它也适用于计算值（年龄）以及那些合理存储的数据（出生日期）。

![image](https://static.zuul.top/java-design-patterns-doc-for-cn/abstract-document/3_1.png)
> 图1.使用固定属性建模的人员
```java
class Person {
public Date getDateOfBirth(); 
public int getAge();
public Quantity getHeight(); 
public Company getEmployer();
public void setDateOfBirth (Date newDateOfBirth); 
public void setEmployer (Company newEmployer);
```
> 列举,图1的`java`操作

- 查询操作通常遵循一些命名约定。在smalltalk中，您总是在属性名称（dateOfBirth）之后命名查询。 C ++从来没有一个固定的约定，有些人只是在属性后面命名，而另一些人则使用“get”约定（getDateOfBirth）。 Java从没有特别的约定开始，但现在大多数人都采用get约定。就我个人而言，当您阅读代码时，我发现“get”令人恼火，所以我宁愿忽略它，但Java风格是使用get，所以现在就使用它。无论您使用的是存储值还是派生值，都应确保遵循相同的约定。人类的客户不应该知道或关心年龄是否存储或派生。

- 修饰符操作的存在取决于您是否希望直接修改值。如果你这样做，那么你会根据一些命名方案，例如setDateOfBirth（Date）提供一个修饰符操作。对于返回值存在不同的约定。你可以返回属性的新值（Date），被修改的对象（Person），或者什么都没有（void）。我更愿意在修饰符上返回void，以帮助明确修饰符和查询之间的区别。

```
  固定属性
 你如何代表一个对象的事实？给它一个这个事实的特定属性。 这将转化为查询方法，并可能是一种编程语言的更新方法。 
  √ 清晰的界面
  × 只能在设计时添加属性
```
- 您可能希望为属性的构造函数提供参数。通常，您要在构造函数中设置足够的属性，以便构建格式良好的类。

- 不想直接修改的属性不应该有修饰符操作。如果您只希望从出生之日起计算，那么年龄属性可能就是这种情况。对于一个不可改变的属性也是如此：一个在类的生命周期中不会改变的属性。当你想使财产不可改变时，请记住考虑到人为错误。虽然出生日期对于现实世界中的人类来说是不可改变的属性，但是您可能会在输入到计算机系统时出现错误，从而使其变得可变。软件常常模拟我们所知道的世界，而不是世界本身。

- 固定属性是迄今为止您将遇到的最常见的属性形式。他们这样做是有原因的：他们使用简单方便。您应该使用固定属性作为表示属性的第一个也是最常见的选择。在本文中，我将给出许多固定属性的替代方案。在某些情况下，这些替代品更好，但大多数情况下不是。请记住，当我们经历的选择。我99％的时间使用固定的属性。其他品种更为复杂，这就是为什么我把这篇论文的大部分花费在他们身上 - 也是为什么我不愿意使用它们！

## <span id = "动态属性">动态属性</span>
- 固定属性的关键在于您在设计时修复了这些属性，并且所有实例在运行时都必须遵循该决定。 对于一些问题，这是一个尴尬的限制。 想象一下，我们正在建立一个复杂的联络系统。 有一些东西是固定的：家庭住址，家庭和工作电话，电子邮件。 但他们是各种各样的小变化。 对于需要记录父母地址的人，另一个人有白天工作和晚上工作号码。 事先很难预测所有这些事情，每次更改系统时都必须经过编译，测试和分发。 要处理这个问题，你需要使用动态属性。
```
  动态属性
  你如何代表一个对象的事实？
  提供可参数化的属性，可以根据参数表示不同的属性 
  √ 可以在运行时添加属性
  × 不清楚的界面
```
- 动态属性有多种变化，每种变化都会在灵活性和安全性之间做出不同的折衷。 最简单的方法是灵活的动态属性。 这种模式的本质是为键值为简单值的人（通常是字符串）添加一个合格的关联（参见图2和清单2）。 如果您想为某人Kent添加休假地址，则只需使用清单3中的代码即可。您不需要重新编译人员类。 你甚至可以建立一个图形用户界面（GUI）或者文件读取器来添加属性，而不用重新编译客户端。
![image](https://static.zuul.top/java-design-patterns-doc-for-cn/abstract-document/5_1.png)
> 图2.使用动态属性建模的人员
```java
class Person {
public Object getValueOf(String key);
public void setValueOf(String key, Object value);
```
> 列举2,图2的`java`方法
```java
kent.setValueOf(“VacationAddress”, anAddress);
Address kentVactation = (Address) kent.getValueOf(“VacationAddress”)
```
> 列举3,使用动态属性
这样说，你可能想知道为什么有人会使用固定的属性，因为动态的像这样的属性给了你更多的灵活性。当然有一个成本，它在于软件各部分之间依赖关系的清晰度降低。这一切都非常好好给一个人增加一个度假地址属性，但是你怎么知道把它重新取回呢？有了固定的属性，你可以看看人的界面，看看属性。该编译器可以检查不要求对象做不理解的事情。 用一个动态属性，你不能做任何设计时检查。此外的界面人很难看。不只是你看Person的声明接口 -你也必须找到不会出现在类接口中的动态属性。你必须找到那些设置属性的代码部分（通常不会在Person类中）挖出来
```
灵活的动态属性
你如何代表一个对象的事实？
提供一个用字符串参数化的属性。 只声明一个属性使用字符串。
```
- 不仅是财产很难找到，它也创造了噩梦的依赖。随着固定属性的客户端代码有一个依赖于人类 - 一个依赖是很容易的不要跟丢。如果你改变属性的名字，编译器会让你知道，并告诉你需要改变什么代码才能解决问题。但灵活的动态属性创建一个依赖于任意一段代码。它可能是属于一个类的代码甚至不能被客户看到。如果有人更改密钥字符串会发生什么？什么如果有人改变他们把键入字符串的对象的类型会发生？不只是可以的编译器无助于你，你甚至不知道从哪里开始寻找潜力变化。

- 灵活的动态属性在最极端的情况下显示了这个问题。该物业可能是Person的任何客户在设计时创建。如果另一个人的客户使用同样的东西©Martin Fowler 1997 6属性你有一个很难找到的两个类之间的依赖关系。此外
属性可以在运行时通过读取文件或通过GUI添加。不可能发现，即使在运行时，一个人的法律动态属性是什么。诚然，你可以问一个人，如果它有一个度假地址的财产-但如果没有一个这是否意味着这一点人没有假期地址，或者是否意味着没有这样的财产度假地址？如果现在没有这样的财产，那并不代表就没有这个财产几秒钟后。
- 灵活动态特性的另一个关键缺点是很难替代它们进行操作。封装的一个关键优势是使用属性的客户端无法分辨它是作为对象数据的一部分存储的，还是通过方法来计算的。这是一个对象方法非常重要的一部分。它可以让你不只是一个普通的界面目的，而且在客户不知情的情况下改变主意。在......的存在下子类型，你甚至可以有一个超类型存储属性和子类计算或副反之亦然。但是，如果要使用动态属性，则只能更改存储的数据一个计算就是在通用访问器中为动态属性设置一个特定的陷阱清单4中的代码。这个代码可能很脆弱，难以维护。
```java
class Person {
public Object getValueOf (String key) {
if (key = “vacationAddress”) return calculatedVacationAddress();
if (key = “vacationPhone”) return getVacationPhone();
// else return stored value…
```
> 列举4,用操作替换动态属性

- 其他形式的动态属性可以帮助您解决其中一些问题，但不是全部。该动态属性的根本缺点是你失去了清晰的界面和所有的设计时间检查。动态属性的不同方法给你不同的能力运行时检查。如果你需要动态属性，并且当然有确定的情况你这样做，那么你只需要放弃设计时间检查和明确的设计时间接口。唯一的问题是如何明确界面和多少检查你可以做的在运行时。使用灵活的动态属性，你也不会得到任何一个。

- 你经常在数据库中发现动态属性，因为改变它通常是一个痛苦数据库模式，特别是如果有大量的数据迁移。分布式的接口例如在CORBA中的组件也经常因为相似的原因而使用动态属性。那里是很多使用界面的远程客户，所以你不愿意改变它。在这两个这些情况并不是编译时和运行时间的区别，而是一个区别设计时间和生产之间的区别。

- 如果你正在做的是通过GUI显示和更新信息，而代码永远不会对键进行固定的引用（即，你永远不会看到像清单3那样的代码），那么你很漂亮安全，灵活的动态属性。这是因为你没有建立一个讨厌的依赖以一些任意字符串作为关键字。否则，你应该考虑其他方法之一动态属性。

- 更多运行时检查的第一步是定义的动态属性。钥匙定义相对于灵活的动态属性之间的区别是所使用的关键动态属性不再是一些任意的字符串，而是现在某个类的一个实例（图3）。

![image](https://static.zuul.top/java-design-patterns-doc-for-cn/abstract-document/7_1.png)
> 图3.定义的动态属性

-在它的表面上使用定义的动态属性并没有太大的改变。确实是代码接口几乎相同（清单5和清单6）。但现在不再选择密钥完全是任意的，它受到接触类型的限制。当然这仍然允许你在运行时添加属性-只需创建一个新的联系人类型。但现在至少有某处可以找到一个潜在的钥匙清单，而不必拖网程序文本。在设计时添加的任何密钥都可以在加载程序中收集接触式类。 您可以轻松地提供服务，以在运行时查找合法的密钥。
```java
class Person {
public Object getValueOf(ContactType key);
public void setValueOf(ContactType key, Object value);
```
> 列举5, 图3的Java接口
```java
class ContactType {
public static Enumeration instances();
public static boolean hasInstanceNamed(String name);
public static ContactType get(String name);
```
> 列举6,为定义的属性类型提供的服务

- 特别是你现在可以设置一些检查，以防止由于某人要求的错误动态属性不存在，如清单7所示。我抛出一个未经检查的异常这里是因为我认为get（）的前提是客户端提供了一个合法的名字对于联系人类型。客户可以通过使用来始终履行这个责任hasInstanceNamed（），但大多数时候客户端软件会挂在联系人类型上对象，而不是字符串。